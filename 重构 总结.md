重构 总结



概念：

在不改变软件可观察行为的前提下改善其内部结构。



重构具有风险。



jest测试



Code 应用场景 进而分析是否需要重构



UML 图，符号含义，绘制一个UML图并精确解释



分解并重组：找出局部变量和参数

任何不会被修改的变量都可以当成参数传入新的函数。



BaseComponent



抽象方法，子类中必须要实现





state模式，传递

扩展开放





Next：UML，状态模式简单代码实现



何为重构



重构：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提，提高其可理解性，降低其修改成本。



重构手法





从最简单的开始做



添加新功能、重构



为何重构

何时重构



高级组件去扩展base组件，选择应该使用的层级



我的时间就是我的资源

时间预算法

持续关注法

性能提升法



过长参数传Obj

：： 适用在一些输入框中，登录注册



if else 可以用map ？？？？



**saga 中间件业务逻辑 API**

**原理、API，某一原理深入了解**



Redux



构筑测试体系

- 自测试代码的价值
  - 确保所有测试都完全自动，让他们自己检查自己的测试结果
  - 一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的时间
  - 频繁进行测试是极限编程的重要一环

- JUnit测试框架
  - 频繁地进行测试，每次编译请把测试也考虑进去，每天至少执行每个测试一次
  - 单元测试和功能测试

- 添加更多测试
  - 边界测试，集中测试失败条件

重构列表

- 重构的记录格式
  - 名称、概要、动机、做法、范例
- 寻找引用点
  - 不要盲目地查找-替换
  - 让编译器帮你寻找漏网之鱼
  - 编译器可能太慢，先试用文本查找工具，编译器复查
  - 编译器无法通过反射机制得到引用点。
- 这些重构手法有多成熟
  - 小步前进、频繁测试
  - 设计模式为重构提供了目标

重新组织函数

- 提炼函数
  - 动机
  - 做法
    - 创造一个新函数
- 内联函数
  - 动机：表现动作，Replace Method with Method Object
  - 做法
    - 检查函数，确定不具有多态性
    - 被调用点
    - 替换函数本体
    - 编译、测试
    - 删除函数定义
  - 递归、多返回点时不应该用
- 内联临时变量
  - 动机：只被赋值使用一次
  - 做法
    - 临时赋值语句，右侧没有副作用
- 以查询取代临时变量
  - 只被赋值一次
  - 无副作用
- 引入解释性变量
  - 动机
  - 做法
- 分解临时变量
- 移除对参数的赋值
- 以函数对象取代函数
- 替换算法



第七章 在对象之间搬移特性

**Move Method：搬移函数**

**Move Field：搬移值域**

**Extract Class：提炼类**

**Inline Class：将类内联化**

**Hide Delegate：隐藏委托关系**

**Remove Middle Man：移除中间人**

**Introduce Foreign Method：引入外加函数**

**Introduce Local Extension：引入本地拓展**

运用重构，来改变自己原先的设计，一步步优化改进自己的项目代码。

起因，为什么要搬移特性？

提炼类：类往往会因为承担过多责任而变得臃肿，这时候就要分离一部分责任

将类内联化：如果一个类承担的责任过少，则会把它融入到另一个类中

隐藏委托关系：一个类使用了另一个类，使用隐藏委托关系将这种关系隐藏起来

移除中间人：有时候隐藏委托类会导致拥有者的接口经常变化

当我不能访问某个类的源码，却又想把其他责任移进这个不可修改的类时

引入外加函数：如果我想加入的只是一或两个函数

引入本地拓展：如果我想加入的不止一两个函数

#### 7.1 搬移函数

在类中，有个函数与其所驻类之外的另一个类进行更多的交流，调用后者，或被后者调用

做法：在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或者将旧函数完全移除

动机：

​	“搬移函数”是重构理论的支柱。

​	一个类有太多行为，或者类与另一个类高度耦和，请选择搬移函数，可以让系统中的类更简单，更干净利落的执行任务。

​	[人在曹营心在汉]一个对象中的函数，在其他对象中调用次数比本对象调用的次数还多，一般做了一些修改之后就要做类似的检查，在调用的一端货任何一个重定义函数，判断函数的依赖性，决定移动路径，进行解耦。

​	凭本能去做，让自己的经验告诉自己最舒服的修改方式，看起来清晰明了，方便理解，以后总是可以修改的。

做法：

- 检查并考虑是否应该被搬移，搬移一个函数还是一组函数
- 查看源类的子类和超类，是否有该函数的其他声明
- 目标类中生命函数，并选择合适个新名称
- 代码迁移，并调试使之正常运行
- 编译目标类
- 决定如何从源函数正确引用目标对象
- 修改源函数，改为纯委托函数
- 编译测试
- 决定是否删除源函数，或者保留委托函数
- 移除源函数的话，要将所有的调用都替换为对目标函数的调用

案例：

Account类中的透支金计费函数，搬移到AccountType类中

1. 观察被使用的特性，_daysOverdrawn 透支天数留在Account类中，overdraftCharge函数复制到AccountType中，做相应调整：调整的意思是
2. 将透支天数作为参数传给目标函数使用
3. 源函数的函数本体替换成一个简单的委托动作
4. 找出所有调用者，将调用方法重定向，再决定是否删除源函数
5. 此时再依赖一下编译器的错误提醒功能

此例子中只用到了一个字段，所以将字段作为参数传给目标函数即可，如果引用了源对象，则如何处理。

分解目标函数，将其中一部分移回源类

#### 7.2 搬移字段 Move Field

在目标类新建一个字段，修改源字段的所有用户，令他们使用新字段

动机

​	对于一个字段，在所在的class之外被另一个类更多的函数使用到它。

做法

​	字段 public，使用封装值域/自封装值域

​	目标类中建立相同字段，同时建立相同的设值和取值函数

如何引用

替换

**案例**

搬移代表利率的字段，并在目标类中建立赋值取值函数

自封装 访问函数修改，调用点不用变动

#### 7.3 提炼类

建立一个新类，将相关字段和函数从旧类中搬移到新类

动机

​	类会不断的成长，当类过分复杂是，就应该对类进行分离，分出去一个单独的类。函数和数据总是一起出现的时候，彼此依赖，应该将他们放到同一个新类中。

做法

​	分解类，责任划分

​	建立一个新类，搬移，并为旧类更新合适的名称

​	建立旧类与新类的联系

​	使用搬移字段

​	使用搬移函数

​	精简接口

​	是否公开

案例

​	Person类中，讲电话号码想换行为分离出来，定义新类，建立连接，使用搬移字段，使用搬移函数

#### 7.4 将类内联化 Inline Class

将类中的所有特性搬移到另一个类中，然后移除源类

动机

​	与提炼类相反，类不再具有单独存在的理由

做法

​	在目标类上声明源类的public协议，并将左右函数委托至源类

​	修改源类引用点，改而引用目标类

​	迁移

​	丧礼

范例

将电话号码类搬移回Person中

#### 7.5 隐藏 委托关系

在服务类上建立客户所需要的所有函数，用以隐藏委托关系



范例

​	john.getDepartment().getManager()

=》 john.getManager()



#### 7.6 移除中间人

让客户直接调用受托类



​	

#### 7.7 引入外加函数

在客户类中建立一个函数，并以第一参数形式传入一个服务类实例

动机



#### 7.8 引入本地扩展

建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类





#### 8 重新组织数据

自封装字段



#### 9 简化条件表达式

分解条件表达式

合并条件表达式

合并重复的条件片段

移除控制标记

以卫语句取代嵌套条件表达式

  		- 什么是卫语句？

以多态取代条件表达式

引入Null对象

引入断言



10 简化函数调用

1. 函数改名，rename Method
2. 添加参数，add parameter
3. 移除参数，remove parameter
4. 将查询函数和修改函数分离
5. 令函数携带参数
6. 以明确函数取代参数
7. 保持对象完整
8. 以函数取代参数
9. 引入参数对象
10. 移除设值函数
11. 隐藏函数
12. 以工厂函数取代构造函数
13. 封装向下转型
14. 以异常取代错误码
15. 以测试取代异常



并发，多线程



11 处理概括关系

1. Pull Up Field 字段上移
2. Pull Up Method 函数上移
3. 构造函数本体上移
4. 函数下移
5. 字段下移
6. 提炼子类
7. 提炼超类
8. 提炼接口
9. 折叠继承体系
10. 塑造模版函数
11. 以委托取代继承
12. 以继承取代委托



子类父类，提升抽象能力



OSI 七层



12 大型重构

1. 梳理并分解继承体系
2. 将过程化设计转化为对象设计
3. 将领域和表述/显示分离
4. 提炼继承体系



TCP

