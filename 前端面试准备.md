### 前端面试准备

[TOC]

#### HTML

#### CSS

#### JavaScript

##### 介绍一下作用域与作用域链

在JavaScript中有执行环境，执行环境定义了变量和函数，执行环境包括全局执行环境和函数执行环境。

###### 全局执行环境

最外围的一个执行环境，在web浏览器中，我们可以认为他是window对象，在nodejs中，global对象。代码载入浏览器时，全局环境被创建，关闭网页或者关闭浏览器时全局变量被销毁。

###### 函数执行环境

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。

###### 全局作用域 globe scope

在全局执行环境中定义的变量具有全局作用域，window对象的内置属性都拥有全局作用域

在函数中定义变量省略var时，那么变量就变为全局变量，拥有全局作用域，不推荐

###### 局部作用域 local scope

在函数内部定义的变量只有在本函数内部才可以访问得到

###### 作用域链 scope chian

全局作用域和局部作用域中变量的访问权限，其实是由作用域链决定的。

每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。

作用域链是函数被创建的作用域中对象的集合。

作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。

作用域链的最前端始终是当前执行的代码所在环境的变量对象，下一变量对象来自包含环境，下一变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链的最后一个对象。

标识符解析是沿着作用域一级一级的向上搜索标识符的过程。搜索过程始终是从作用域的前端逐地向后回溯，直到找到标识符，找不到会报错。

###### 提升 hoisting

###### 变量提升 variable hoisting

把变量声明提升到函数的顶部，不会把赋值也提升

###### 函数提升 

```javascript
function () {
    func();
	function func(){
		console.log("可以被提升");
	}
}
```



#### 原型链

##### 创建对象

###### 创建对象的方法

```javascript
// 字面量
var o1 = {name: 'o1'}
var o2 = new Object({name: 'o2'})

// 构造函数
var M = function(name) {this.name = name;}
var o3 = new M('o3')

// Object.create
var p = {name : 'p'}
var o4 = Object.create(p)


```



##### 原形、构造函数、实例、原型链

###### 什么是原型链？

原型链就是原型组成的链，对象的`__proto__`是它的原型，而原型也是一个对象，也有`__proto__`属性，循环往复，当找到Object的原型时，这条原型链就结束了

原型对象和实例之间有什么作用？

通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择，这时候就该用上原型了。

在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。

JS引擎分析方式中，在访问一个实例的属性时，先在实例的本身中找，如果没找到就去它的原型中找，还没找到就再往上找，直到找到。这就是原型链。

PS：

1. 只有函数有prototype属性，对象是没有的
2. 但是函数也有`__proto__`属性，因为函数也是对象，函数的`__proto__`指向的是Function.prototype，也就是说普通函数是Function这个构造函数的一个实例。

###### instanceof原理

instanceof是判断实力对象的`__proto__`和生成该实例的构造函数的`prototype`是不是引用的同一个地址

PS：

实例的instanceof在比较的时候，与原型上向上找的构造函数相比都是true

使用constructor判断实例是由哪个构造函数生成的

如：`obj.__proto__.constructor`

###### new运算符

